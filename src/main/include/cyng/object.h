/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2017 Sylko Olzscher 
 * 
 */ 
#ifndef CYNG_OBJECT_H
#define CYNG_OBJECT_H


#include <cyng/factory/factory_fwd.hpp>
#include <cyng/core/object_cast_fwd.h>
#include <cyng/core/value_cast_fwd.h>
#include <cyng/core/wrapper_fwd.h>
#include <functional>

namespace cyng 
{

	class tracker;
	class reference;

	/**@brief Generic data type 
	 * 
	 * Provides a runtime dynamically typed value for C++, similar to the way languages
	 * with runtime type systems work (e.g. Python). It can hold types from a predetermined
	 * set of types (ints, bools, arrays of other dynamics, etc), similar to something
	 * like boost::any, but the syntax is intended to be a little more like using the
	 * native type directly.
	 * 
	 * An cyng-object is a lightweight object which only contains a pointer to its internal
	 * shared value. Thus it can be copied around without worrying about
	 * performance. Further it is not necessary to create or pass pointers to cyng-
	 * objects.
	 * 
	 * <ul>
	 * <li>To get a pointer to the shared value use object_cast<T>() or value_cast<T>(). 
	 * (There are more casts available.)</li>
	 * <li>To do some math with object include cyng/math.h</li>
	 * <li>To create objects include cyng/intrinsics/factory.h</li>
	 * <li>To compare objects include cyng/intrinsics/compare.h</li>
	 * <li>To get the size include cyng/intrinsics/size.h</li>
	 * </ul>
	 */
	class object
	{
		friend class tracker;
		friend class reference;
		friend void swap(object&, object&) noexcept;
		friend bool equal_by_instance(object const&, object const&) noexcept;
		friend bool equal_by_value(object const&, object const&) noexcept;
		friend bool less_by_value(object const&, object const&) noexcept;
		template <typename T>
		friend class core::wrapper;
		template <typename T>
		friend struct factory;
		template < typename T >
		friend const T* object_cast(object const&) noexcept;
		template <typename T>
		friend T value_cast(object const&, T const&) noexcept;
		template < typename T, typename U >
		friend T construct_cast(object const&, U const&) noexcept;
		template <typename T>
		friend struct std::less;

	public:
		/**
		 * To use an object in a STL container class
		 * a default constructor is required (std::vector is an exception).
		 * Otherwise the use of the empty factory() method
		 * is highly recommended. 
		 */
		object();
		
		/**
		 * Simple copy constructor. Shares ownership.
		 */
		object(object const& obj);
		
		/**
		 * Move-constructs an object from obj. After the construction, *this contains 
		 * a copy of the previous state of obj and obj is empty. 
		 */
		object(object&& obj);
		
		/**
		 * Shares ownership of the object managed by obj. 
		 */
		object& operator=(object const& obj);

		/**
		 * Move-assigns a value from obj. After the assignment, *this contains 
		 * a copy of the previous state of obj, obj is empty.
		 */
		object& operator=(object&& obj);

		/**
		 * destructor
		 */
		virtual ~object() noexcept;
		
		/** @brief implementing the concept of a NULL or "no value at all".
		 * 
		 * Checks whether object contains a value or null.
		 * 
		 * @return true if object contains a value, false if object 
		 * does not contain a value (null) or the null object.
		 */
		explicit operator bool() const noexcept;

		/**
		 * @return true if the object contains a value 
		 * and this value is the null object.
		 */
		bool is_null() const noexcept;
				
		/**
		 * @return type information generated by the implementation.
		 */
		core::class_interface const& get_class() const noexcept;
		
		/**
		 * Reset internal value.
		 */
		void clear();
		
		/**
		 * Reiteration of std::hash
		 */
		std::size_t hash() const noexcept;
		
		
	private:
		/**
		 * Constructor used by factory 
		 */
		object(core::shared_object);
		
	private:
		/**
		 * holds the hidden value
		 */
		core::shared_object	value_;
	};
	
	/**
	 * Swap two objects
	 */
	void swap(object&, object&) noexcept;
	
	/** @brief Test identity of objects.
	 * 
	 * Objects are identically if they share the same address.
	 * This is possible since different objects can share the same
	 * instance.
	 *
	 *	@return true if both object values share the same address.
	 */
	bool equal_by_instance(object const&, object const&) noexcept;
	
	/** @brief Compare objects by value
	 * 
	 * Objects are equal if they have the same value.
	 *
	 *	@return true if both objects have the same value.
	 */
	bool equal_by_value(object const&, object const&) noexcept;

	/**
	 * Compare objects by value.
	 * 
	 * @see equal_by_value(object const&, object const&) noexcept
	 */
	bool operator==(object const&, object const&);
	bool operator!=(object const&, object const&);

	/** @brief Compare objects by value
	 * 
	 * If objects o1 and o2 of different types the function returns false.
	 *
	 *	@return true if value of o1 is less than value of o2 if both
	 *	objects of the same type.
	 */
	bool less_by_value(object const& o1, object const& o2) noexcept;

	/**
	 * @see less_by_value()
	 */
	bool operator<(object const&, object const&);
}
 
namespace std 
{
	/**
	 * Specializations of std::hash<> for cyng::object.
	 * This specialization should allow to use cyng::object
	 * in STL containers that require a hash value.
	 */
	template<> 
	struct hash<cyng::object>
	{
		size_t operator()(cyng::object const& obj) const noexcept;
	};
}
 

#endif	//	CYNG_OBJECT_H

